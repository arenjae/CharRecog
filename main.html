<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0" />

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.4.1/math.min.js"></script>

    <link rel="stylesheet" href="css/style.css">

</head>
<body>
    <h1>Neural Network Digit Recognizer</h1>
    <div class="container">
        <div id="bar">
            <button id="reset" onclick="clearCanvas()">reset</button>
            <button id="evaluate" onclick="recognize()">evaluate</button>
            <div style="padding-bottom:5px;"><input type="checkbox" id="preprocessing"><span style="margin-left:5px;">Display Preprocessing</span></div>
            <div id="input"></div>
            <div id="output"></div>
        </div>
        <canvas id="drawpad" width="280" height="280"></canvas>
    </div>



    <script type="text/javascript" src="js/canvas.js"></script>
    <script type="text/javascript" src="js/neural.js"></script>


    <div style="margin-bottom:10px;"></div>
    <script type="text/javascript">
        // some of the code below was taken from a stackoverflow flag I cannot find anymore, and adapted to my needs.
        // Thanks a ton to the original author!
        var ctx;

        // the neural network's weights (unit-unit weights, and unit biases)
        // training was done in Matlab with the MNIST dataset.
        // this data is for a 784-200-10 unit, with logistic non-linearity in the hidden and softmax in the output layer.
        // The input is a [-1;1] gray level image, background == 1, 28x28 pixels linearized in column order (i.e. column1(:); column2(:); ...)
        // i-th output being the maximum means the network thinks the input encodes (i-1)
        // the weights below showed a 1.92% error rate on the test data set (9808/10000 digits recognized correctly).
        // neural net with one hidden layer; sigmoid for hidden, softmax for output
        // take canvas image and convert to grayscale. Mainly because my
        // own functions operate easier on grayscale, but some stuff like
        // resizing and translating is better done with the canvas functions

        function imageDataToGrayscale(imgData) {
            var grayscaleImg = [];
            for (var y = 0; y < imgData.height; y++) {
                grayscaleImg[y]=[];
                for (var x = 0; x < imgData.width; x++) {
                    var offset = y * 4 * imgData.width + 4 * x;
                    var alpha = imgData.data[offset+3];
                    if (alpha == 0) {
                        imgData.data[offset] = 255;
                        imgData.data[offset+1] = 255;
                        imgData.data[offset+2] = 255;
                    }
                    imgData.data[offset+3] = 255;
                    // simply take red channel value. Not correct, but works for
                    // black or white images.
                    grayscaleImg[y][x] = imgData.data[y*4*imgData.width + x*4] / 255;
                }
            }
            return grayscaleImg;
        }

        // takes the image in the canvas, centers & resizes it, then puts into 10x10 px bins
        // to give a 28x28 grayscale image; then, computes class probability via neural network
        function recognize() {

            // convert RGBA image to a grayscale array, then compute bounding rectangle and center of mass
            // now bin image into 10x10 blocks (giving a 28x28 image)
            var imgData = ctx.getImageData(0, 0, 280, 280);
            var grayscaleImg = imageDataToGrayscale(imgData);
            var inputArr = new Array(784);
            for (var y = 0; y < 28; y++) {
                for (var x = 0; x < 28; x++) {
                    var mean = 0;
                    for (var v = 0; v < 10; v++) {
                        for (var h = 0; h < 10; h++) {
                            mean += grayscaleImg[y*10 + v][x*10 + h];
                        }
                    }
                    mean = (1 - mean / 100); // average and invert
                    inputArr[x*28+y] = (mean - .5) / .5;
                }
            }

            var net = new Network();
            document.getElementById('output').innerHTML=net.evaluate(inputArr).toString();
        }

    </script>
</body>
</html>
