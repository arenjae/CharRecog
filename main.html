<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0" />

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.4.1/math.min.js"></script>

    <link rel="stylesheet" href="css/style.css">

</head>
<body>
    <h1>Neural Network Digit Recognizer</h1>
    <div class="container">
        <div id="bar">
            <button id="reset" onclick="clearCanvas()">reset</button>
            <button id="evaluate" onclick="recognize()">evaluate</button>
            <div style="padding-bottom:5px;"><input type="checkbox" id="preprocessing"><span style="margin-left:5px;">Display Preprocessing</span></div>
            <div id="input"></div>
            <div id="output"></div>
        </div>
        <canvas id="drawpad" width="280" height="280"></canvas>
    </div>



    <script type="text/javascript" src="js/canvas.js"></script>
    <script type="text/javascript" src="js/neural.js"></script>

</body>
<!--</html>-->

<body style="padding:5px;">

<div class="container bs-docs-container">
    <!--<div class="container">-->
        <!--<div><p>Draw a digit in the box below and click the "recognize" button.</p></div>-->
        <!--<div class="container" style="float:left;">-->
            <!--<div>-->
                <!--<canvas id="can" width="280" height="280" style="top:10%;left:10%;border:2px solid;"></canvas>-->
            <!--</div>-->
            <!--<div class="container">-->
                <!--<div style="padding-bottom:5px;"><input type="checkbox" id="preprocessing"><span style="margin-left:5px;">Display Preprocessing</span></div>-->
                <!--<div style="float:left;padding-right:10px;"><input type="button" value="clear" id="clr" size="23" onclick="erase()"></div>-->
                <!--<div style="float:left;"><input type="button" value="recognize" id="recognize" size="23" onclick="recognize()"></div>-->
                <!--<div id="nnInput"></div>-->
            <!--</div>-->
        <!--</div>-->
        <!--<div style="float:left;font-size:200px;margin-left:80px;" id="nnOut"></div>-->
    <!--</div>-->

    <div style="margin-bottom:10px;"></div>
    <!--<script type="text/javascript" src="js/neural.js"></script>-->
    <script type="text/javascript">
        // some of the code below was taken from a stackoverflow flag I cannot find anymore, and adapted to my needs.
        // Thanks a ton to the original author!
        var canvas;
        var ctx;

        var prevX = 0;
        var currX = 0;
        var prevY = 0;
        var currY = 0;
        var paths = []; // recording paths
        var paintFlag = false;
        var color = "black";
        var lineWidth = 20;

        var clearBeforeDraw = false; // controls whether canvas will be cleared on next mousedown event. Set to true after digit recognition

        // the neural network's weights (unit-unit weights, and unit biases)
        // training was done in Matlab with the MNIST dataset.
        // this data is for a 784-200-10 unit, with logistic non-linearity in the hidden and softmax in the output layer.
        // The input is a [-1;1] gray level image, background == 1, 28x28 pixels linearized in column order (i.e. column1(:); column2(:); ...)
        // i-th output being the maximum means the network thinks the input encodes (i-1)
        // the weights below showed a 1.92% error rate on the test data set (9808/10000 digits recognized correctly).
        // neural net with one hidden layer; sigmoid for hidden, softmax for output
        // take canvas image and convert to grayscale. Mainly because my
        // own functions operate easier on grayscale, but some stuff like
        // resizing and translating is better done with the canvas functions

        function imageDataToGrayscale(imgData) {
            var grayscaleImg = [];
            for (var y = 0; y < imgData.height; y++) {
                grayscaleImg[y]=[];
                for (var x = 0; x < imgData.width; x++) {
                    var offset = y * 4 * imgData.width + 4 * x;
                    var alpha = imgData.data[offset+3];
                    // weird: when painting with stroke, alpha == 0 means white;
                    // alpha > 0 is a grayscale value; in that case I simply take the R value
                    if (alpha == 0) {
                        imgData.data[offset] = 255;
                        imgData.data[offset+1] = 255;
                        imgData.data[offset+2] = 255;
                    }
                    imgData.data[offset+3] = 255;
                    // simply take red channel value. Not correct, but works for
                    // black or white images.
                    grayscaleImg[y][x] = imgData.data[y*4*imgData.width + x*4] / 255;
                }
            }
            return grayscaleImg;
        }

        // takes the image in the canvas, centers & resizes it, then puts into 10x10 px bins
        // to give a 28x28 grayscale image; then, computes class probability via neural network
        function recognize() {

            // convert RGBA image to a grayscale array, then compute bounding rectangle and center of mass
            var imgData = ctx.getImageData(0, 0, 280, 280);
            grayscaleImg = imageDataToGrayscale(imgData);

            var canvasCopy = document.createElement("canvas");
            canvasCopy.width = imgData.width;
            canvasCopy.height = imgData.height;
            var copyCtx = canvasCopy.getContext("2d");

            // default take image from original canvas
            copyCtx.drawImage(ctx.canvas, 0, 0);


            // now bin image into 10x10 blocks (giving a 28x28 image)
            imgData = copyCtx.getImageData(0, 0, 280, 280);
            grayscaleImg = imageDataToGrayscale(imgData);
            var nnInput = new Array(784);
            for (var y = 0; y < 28; y++) {
                for (var x = 0; x < 28; x++) {
                    var mean = 0;
                    for (var v = 0; v < 10; v++) {
                        for (var h = 0; h < 10; h++) {
                            mean += grayscaleImg[y*10 + v][x*10 + h];
                        }
                    }
                    mean = (1 - mean / 100); // average and invert
                    nnInput[x*28+y] = (mean - .5) / .5;
                }
            }

            // for visualization/debugging: paint the input to the neural net.
            if (document.getElementById('preprocessing').checked == true) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(copyCtx.canvas, 0, 0);
                for (var y = 0; y < 28; y++) {
                    for (var x = 0; x < 28; x++) {
                        var block = ctx.getImageData(x * 10, y * 10, 10, 10);
                        var newVal = 255 * (0.5 - nnInput[x*28+y]/2);
                        for (var i = 0; i < 4 * 10 * 10; i+=4) {
                            block.data[i] = newVal;
                            block.data[i+1] = newVal;
                            block.data[i+2] = newVal;
                            block.data[i+3] = 255;
                        }
                        ctx.putImageData(block, x * 10, y * 10);
                    }
                }
            }

//            var maxIndex = 0;
            var net = new Network();

//            console.log('maxIndex: '+maxIndex);
            console.log('got somewhere');
            document.getElementById('output').innerHTML=net.evaluate(nnInput).toString();
            clearBeforeDraw = true;
        }

        function init() {
            canvas = document.getElementById('drawpad');
            ctx = canvas.getContext("2d");

            canvas.addEventListener("mousemove", function (e) {
                findxy('move', e)
            }, false);
            canvas.addEventListener("mousedown", function (e) {
                findxy('down', e)
            }, false);
            canvas.addEventListener("mouseup", function (e) {
                findxy('up', e)
            }, false);
            canvas.addEventListener("mouseout", function (e) {
                findxy('out', e)
            }, false);
        }

        // draws a line from (x1, y1) to (x2, y2) with nice rounded caps
        function draw(ctx, color, lineWidth, x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.closePath();
        }

        function erase() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('nnOut').innerHTML = '';
        }

        function findxy(res, e) {
            if (res == 'down') {
                if (clearBeforeDraw == true) {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    document.getElementById('nnInput').innerHTML='';
                    document.getElementById('nnOut').innerHTML='';
                    paths = [];
                    clearBeforeDraw = false;
                }

                if (e.pageX != undefined && e.pageY != undefined) {
                    currX = e.pageX - canvas.offsetLeft;
                    currY = e.pageY - canvas.offsetTop;
                }

                //draw a circle
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.arc(currX,currY,lineWidth/2,0,2*Math.PI);
                ctx.stroke();
                ctx.closePath();
                ctx.fill();

                paths.push([[currX], [currY]]);
                paintFlag = true;
            }
            if (res == 'up' || res == "out") {
                paintFlag = false;
            }

            if (res == 'move') {
                if (paintFlag) {
                    // draw a line to previous point
                    prevX = currX;
                    prevY = currY;
                    if (e.pageX != undefined && e.pageY != undefined) {
                        currX = e.pageX-canvas.offsetLeft;
                        currY = e.pageY-canvas.offsetTop;
                    }
                    var currPath = paths[paths.length-1];
                    currPath[0].push(currX);
                    currPath[1].push(currY);
                    paths[paths.length-1] = currPath;
                    draw(ctx, color, lineWidth, prevX, prevY, currX, currY);
                }
            }
        }
        init();
    </script>
    <div id="errorDiv" style="color:#FF0000;"></div>
</div>
</body>
</html>
